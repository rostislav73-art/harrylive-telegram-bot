import os
import re
import requests
from flask import Flask, request
from openai import OpenAI
import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton

app = Flask(__name__)

BOT_TOKEN = os.getenv("BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENWEATHER_API_KEY = os.getenv("OPENWEATHER_API_KEY")
WEBHOOK_URL = "https://web-production-f7800.up.railway.app/webhook"

bot = telebot.TeleBot(BOT_TOKEN, parse_mode='Markdown')
client = OpenAI(api_key=OPENAI_API_KEY)

user_context = {}  # –Ω–æ–≤ —Ä–µ—á–Ω–∏–∫ –∑–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ

def get_weather(city="Sofia"):
    if not city.strip():
        return "‚ö†Ô∏è *–ú–æ–ª—è, –≤—ä–≤–µ–¥–∏ –≤–∞–ª–∏–¥–Ω–æ –∏–º–µ –Ω–∞ –≥—Ä–∞–¥!*"
    url = f"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city}?unitGroup=metric&lang=bg&key={OPENWEATHER_API_KEY}&contentType=json"
    try:
        res = requests.get(url)
        if res.status_code != 200:
            print("Weather API error:", res.text)
            return "‚ö†Ô∏è *–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –≤–∑–µ–º–∞–Ω–µ –Ω–∞ –ø—Ä–æ–≥–Ω–æ–∑–∞—Ç–∞ –∑–∞ –≤—Ä–µ–º–µ—Ç–æ.*"
        data = res.json()
        if "days" not in data:
            return "‚ö†Ô∏è *–ù—è–º–∞ –ø—Ä–æ–≥–Ω–æ–∑–∞ –∑–∞ —Ç–æ–≤–∞ –º—è—Å—Ç–æ.*"
        day = data["days"][0]
        temp = day.get("temp")
        conditions = day.get("conditions", "").lower()
        humidity = day.get("humidity")

        icons = {
            "rain": "üåßÔ∏è", "overcast": "‚òÅÔ∏è", "cloud": "‚òÅÔ∏è",
            "clear": "‚òÄÔ∏è", "snow": "‚ùÑÔ∏è", "thunderstorm": "‚õàÔ∏è"
        }
        weather_icon = "üå°Ô∏è"
        for key, icon in icons.items():
            if key in conditions:
                weather_icon = icon
                break

        return f"{weather_icon} *–í –º–æ–º–µ–Ω—Ç–∞ –≤ {city} –µ {temp}¬∞C —Å {conditions}.*\nüíß –í–ª–∞–∂–Ω–æ—Å—Ç: {humidity}%"
    except Exception as e:
        print("Weather API exception:", e)
        return "‚ö†Ô∏è *–í—ä–∑–Ω–∏–∫–Ω–∞ –≥—Ä–µ—à–∫–∞ –ø—Ä–∏ –≤—Ä—ä–∑–∫–∞—Ç–∞ —Å –ø—Ä–æ–≥–Ω–æ–∑–∞—Ç–∞.*"

def ask_gpt(message_text):
    if not message_text.strip():
        return "‚ö†Ô∏è *–ú–æ–ª—è, –≤—ä–≤–µ–¥–∏ —Å—ä–æ–±—â–µ–Ω–∏–µ!*"
    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "–¢–∏ —Å–∏ –ø–æ–ª–µ–∑–µ–Ω Telegram –±–æ—Ç, –∫–æ–π—Ç–æ –ø–æ–º–∞–≥–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è."},
                {"role": "user", "content": message_text}
            ],
            temperature=0.7,
            max_tokens=500,
        )
        return response.choices[0].message.content
    except Exception as e:
        print("OpenAI error:", e)
        return "‚ö†Ô∏è *–í—ä–∑–Ω–∏–∫–Ω–∞ –≥—Ä–µ—à–∫–∞ –ø—Ä–∏ –≤—Ä—ä–∑–∫–∞—Ç–∞ —Å GPT.*"

@bot.message_handler(commands=['start'])
def start_handler(message):
    markup = InlineKeyboardMarkup()
    markup.add(InlineKeyboardButton("\ud83c\udf26Ô∏è –ü–æ–ø–∏—Ç–∞–π –∑–∞ –≤—Ä–µ–º–µ—Ç–æ", callback_data="weather"))
    markup.add(InlineKeyboardButton("\ud83d\udcac –ì–æ–≤–æ—Ä–∏ —Å GPT", callback_data="chatgpt"))
    markup.add(InlineKeyboardButton("\u2139\ufe0f –ü–æ–º–æ—â", callback_data="help"))
    bot.send_message(message.chat.id, "\ud83c\udf10 *–î–æ–±—Ä–µ –¥–æ—à—ä–ª! –ò–∑–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ –æ—Ç –º–µ–Ω—é—Ç–æ:*", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: True)
def callback_query(call):
    chat_id = call.message.chat.id
    if call.data == "weather":
        user_context[chat_id] = "awaiting_city"
        bot.send_message(chat_id, "‚úçÔ∏è *–ù–∞–ø–∏—à–∏ –∏–º–µ—Ç–æ –Ω–∞ –≥—Ä–∞–¥–∞, –∑–∞ –¥–∞ —Ç–∏ –¥–∞–º –ø—Ä–æ–≥–Ω–æ–∑–∞!*")
    elif call.data == "chatgpt":
        user_context[chat_id] = "chatgpt"
        bot.send_message(chat_id, "\ud83d\udcac *–ü–∏—à–∏ –º–∏ –≤—ä–ø—Ä–æ—Å –∏ —â–µ —Ç–∏ –æ—Ç–≥–æ–≤–æ—Ä—è –∫–∞—Ç–æ GPT-4!* ‚ú®")
    elif call.data == "help":
        bot.send_message(chat_id, "\u2139\ufe0f *–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:*\n\n\ud83c\udf26Ô∏è –ù–∞—Ç–∏—Å–Ω–∏ '–ü–æ–ø–∏—Ç–∞–π –∑–∞ –≤—Ä–µ–º–µ—Ç–æ' –∏ –Ω–∞–ø–∏—à–∏ –≥—Ä–∞–¥ –∑–∞ –ø—Ä–æ–≥–Ω–æ–∑–∞.\n\ud83d\udcac –ù–∞—Ç–∏—Å–Ω–∏ '–ì–æ–≤–æ—Ä–∏ —Å GPT', –∑–∞ –¥–∞ –º–∏ –∑–∞–¥–∞–¥–µ—à –≤—ä–ø—Ä–æ—Å.\n\n‚ú® *–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –∫–∞–∫–≤–æ —Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å—É–≤–∞!* ‚úçÔ∏è")

@bot.message_handler(func=lambda message: True)
def echo_all(message):
    chat_id = message.chat.id
    text = message.text.strip()

    if text.startswith("/"):
        bot.send_message(chat_id, "‚ùì *–ù–µ—Ä–∞–∑–ø–æ–∑–Ω–∞—Ç–∞ –∫–æ–º–∞–Ω–¥–∞. –ò–∑–ø–æ–ª–∑–≤–∞–π –º–µ–Ω—é—Ç–æ /start ‚ú®")
        return

    state = user_context.get(chat_id)

    if state == "awaiting_city":
        reply = get_weather(text)
        bot.send_message(chat_id, reply)
        user_context[chat_id] = None
    else:
        reply = ask_gpt(text)
        bot.send_message(chat_id, reply)

@app.route("/webhook", methods=["POST"])
def telegram_webhook():
    if request.headers.get('content-type') == 'application/json':
        json_string = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_string)
        bot.process_new_updates([update])
    return {'ok': True}

@app.route("/")
def index():
    return "ü§ñ Bot is live! Use /webhook for Telegram updates."

import requests as rq

def set_webhook():
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/setWebhook?url={WEBHOOK_URL}"
    try:
        res = rq.get(url)
        print("Webhook set:", res.json())
    except Exception as e:
        print("Failed to set webhook:", e)

set_webhook()

if __name__ == "__main__":
    app.run(debug=True)
